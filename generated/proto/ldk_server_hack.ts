// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.21.12
// source: proto/ldk_server_hack.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import Long = require("long");

export const protobufPackage = "ldk_server_hack";

export enum PaymentDirection {
  INBOUND = 0,
  OUTBOUND = 1,
  UNRECOGNIZED = -1,
}

export function paymentDirectionFromJSON(object: any): PaymentDirection {
  switch (object) {
    case 0:
    case "INBOUND":
      return PaymentDirection.INBOUND;
    case 1:
    case "OUTBOUND":
      return PaymentDirection.OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentDirection.UNRECOGNIZED;
  }
}

export function paymentDirectionToJSON(object: PaymentDirection): string {
  switch (object) {
    case PaymentDirection.INBOUND:
      return "INBOUND";
    case PaymentDirection.OUTBOUND:
      return "OUTBOUND";
    case PaymentDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentStatus {
  PENDING = 0,
  SUCCEEDED = 1,
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PENDING":
      return PaymentStatus.PENDING;
    case 1:
    case "SUCCEEDED":
      return PaymentStatus.SUCCEEDED;
    case 2:
    case "FAILED":
      return PaymentStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PENDING:
      return "PENDING";
    case PaymentStatus.SUCCEEDED:
      return "SUCCEEDED";
    case PaymentStatus.FAILED:
      return "FAILED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetNodeIdRequest {
}

export interface GetNodeIdResponse {
  nodeId: string;
}

export interface GetNodeStatusRequest {
}

export interface GetNodeStatusResponse {
  publicKey: string;
  currentBestBlock: BestBlock | undefined;
  latestWalletSyncTimestamp?: number | undefined;
  latestOnchainWalletSyncTimestamp?: number | undefined;
  latestFeeRateCacheUpdateTimestamp?: number | undefined;
  latestRgsSnapshotTimestamp?: number | undefined;
  latestNodeAnnouncementBroadcastTimestamp?: number | undefined;
}

export interface BestBlock {
  blockHash: string;
  height: number;
}

/** Retrieve a new on-chain/funding address. */
export interface OnchainReceiveRequest {
}

export interface OnchainReceiveResponse {
  address: string;
}

/** Send an on-chain payment to the given address. */
export interface OnchainSendRequest {
  address: string;
  amountSats?: number | undefined;
}

export interface OnchainSendResponse {
  txid: string;
}

/** Return a BOLT11 invoice for the given amount, if specified. */
export interface Bolt11ReceiveRequest {
  description: string;
  expirySecs: number;
  amountMsat?: number | undefined;
}

export interface Bolt11ReceiveResponse {
  invoice: string;
}

/** Send a payment for a BOLT11 invoice. */
export interface Bolt11SendRequest {
  invoice: string;
  amountMsat?: number | undefined;
}

export interface Bolt11SendResponse {
  paymentId: PaymentId | undefined;
}

/** Return a BOLT12 offer for the given amount, if specified. */
export interface Bolt12ReceiveRequest {
  description: string;
  amountMsat?: number | undefined;
}

export interface Bolt12ReceiveResponse {
  offer: string;
}

/** Send a payment for a BOLT11 invoice. */
export interface Bolt12SendRequest {
  offer: string;
  amountMsat?: number | undefined;
  payerNote?: string | undefined;
}

export interface Bolt12SendResponse {
  paymentId: PaymentId | undefined;
}

/** An identifier for making a payment. */
export interface PaymentId {
  data: Uint8Array;
}

export interface ListChannelsRequest {
}

export interface ListChannelsResponse {
  channels: Channel[];
}

export interface OpenChannelRequest {
  nodeId: string;
  address: string;
  channelAmountSats: number;
  pushToCounterpartyMsat?: number | undefined;
  announceChannel: boolean;
}

export interface OpenChannelResponse {
  userChannelId: Uint8Array;
}

export interface CloseChannelRequest {
  userChannelId: Uint8Array;
  counterpartyNodeId: string;
}

export interface CloseChannelResponse {
}

export interface ForceCloseChannelRequest {
  userChannelId: Uint8Array;
  counterpartyNodeId: string;
}

export interface ForceCloseChannelResponse {
}

export interface Channel {
  /**
   * The channel ID (prior to funding transaction generation, this is a random 32-byte
   * identifier, afterwards this is the transaction ID of the funding transaction XOR the
   * funding transaction output).
   *
   * Note that this means this value is *not* persistent - it can change once during the
   * lifetime of the channel.
   */
  channelId: string;
  /** The node ID of our the channel's remote counterparty. */
  counterpartyNodeId: string;
  /**
   * The channel's funding transaction output, if we've negotiated the funding transaction with
   * our counterparty already.
   */
  fundingTxo?:
    | Outpoint
    | undefined;
  /** The value, in satoshis, of this channel as it appears in the funding output. */
  channelValueSats: number;
  /**
   * The currently negotiated fee rate denominated in satoshi per 1000 weight units,
   * which is applied to commitment and HTLC transactions.
   */
  feerateSatPer1000Weight: number;
  /**
   * The available outbound capacity for sending HTLCs to the remote peer.
   *
   * The amount does not include any pending HTLCs which are not yet resolved (and, thus, whose
   * balance is not available for inclusion in new outbound HTLCs). This further does not include
   * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
   */
  outboundCapacityMsat: number;
  /**
   * The available outbound capacity for sending HTLCs to the remote peer.
   *
   * The amount does not include any pending HTLCs which are not yet resolved
   * (and, thus, whose balance is not available for inclusion in new inbound HTLCs). This further
   * does not include any pending outgoing HTLCs which are awaiting some other resolution to be
   * sent.
   */
  inboundCapacityMsat: number;
  /**
   * The number of required confirmations on the funding transactions before the funding is
   * considered "locked". The amount is selected by the channel fundee.
   *
   * The value will be `None` for outbound channels until the counterparty accepts the channel.
   */
  confirmationsRequired?:
    | number
    | undefined;
  /** The current number of confirmations on the funding transaction. */
  confirmations?:
    | number
    | undefined;
  /** Is `true` if the channel was initiated (and therefore funded) by us. */
  isOutbound: boolean;
  /**
   * Is `true` if both parties have exchanged `channel_ready` messages, and the channel is
   * not currently being shut down. Both parties exchange `channel_ready` messages upon
   * independently verifying that the required confirmations count provided by
   * `confirmations_required` has been reached.
   */
  isChannelReady: boolean;
  /**
   * Is `true` if the channel (a) `channel_ready` messages have been exchanged, (b) the
   * peer is connected, and (c) the channel is not currently negotiating shutdown.
   *
   * This is a strict superset of `is_channel_ready`.
   */
  isUsable: boolean;
  /** Is `true` if this channel is (or will be) publicly-announced */
  isPublic: boolean;
  /**
   * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
   * the channel.
   */
  cltvExpiryDelta?:
    | number
    | undefined;
  /**
   * The smallest value HTLC (in msat) the remote peer will accept, for this channel.
   *
   * This field is only `None` before we have received either the `OpenChannel` or
   * `AcceptChannel` message from the remote peer.
   */
  counterpartyOutboundHtlcMinimumMsat?:
    | number
    | undefined;
  /** The largest value HTLC (in msat) the remote peer currently will accept, for this channel. */
  counterpartyOutboundHtlcMaximumMsat?:
    | number
    | undefined;
  /**
   * The available outbound capacity for sending a single HTLC to the remote peer. This is
   * similar to `outbound_capacity_msat` but it may be further restricted by
   * the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
   * to use a limit as close as possible to the HTLC limit we can currently send.
   */
  nextOutboundHtlcLimitMsat: number;
  /**
   * The minimum value for sending a single HTLC to the remote peer. This is the equivalent of
   * `next_outbound_htlc_limit_msat` but represents a lower-bound, rather than
   * an upper-bound. This is intended for use when routing, allowing us to ensure we pick a
   * route which is valid.
   */
  nextOutboundHtlcMinimumMsat: number;
  /**
   * The number of blocks (after our commitment transaction confirms) that we will need to wait
   * until we can claim our funds after we force-close the channel. During this time our
   * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
   * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
   * time to claim our non-HTLC-encumbered funds.
   *
   * This value will be `None` for outbound channels until the counterparty accepts the channel.
   */
  forceCloseSpendDelay?:
    | number
    | undefined;
  /**
   * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
   * over the channel.
   */
  forwardingFeeProportionalMillionths: number;
  /**
   * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
   * excess of [`forwarding_fee_proportional_millionths`].
   */
  forwardingFeeBaseMsat: number;
}

/** Represents to transaction output. */
export interface Outpoint {
  /** The referenced transaction's txid. */
  txid: string;
  /** The index of the referenced output in its transaction's vout. */
  vout: number;
}

export interface ClaimableOnChannelClose {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
}

export interface ClaimableAwaitingConfirmations {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
  confirmationHeight: number;
}

export interface ContentiousClaimable {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
  timeoutHeight: number;
  paymentHash: string;
  paymentPreimage: string;
}

export interface MaybeTimeoutClaimableHTLC {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
  claimableHeight: number;
  paymentHash: string;
}

export interface MaybePreimageClaimableHTLC {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
  expiryHeight: number;
  paymentHash: string;
}

export interface CounterpartyRevokedOutputClaimable {
  channelId: string;
  counterpartyNodeId: string;
  amountSatoshis: number;
}

export interface LightningBalance {
  claimableOnChannelClose?: ClaimableOnChannelClose | undefined;
  claimableAwaitingConfirmations?: ClaimableAwaitingConfirmations | undefined;
  contentiousClaimable?: ContentiousClaimable | undefined;
  maybeTimeoutClaimableHtlc?: MaybeTimeoutClaimableHTLC | undefined;
  maybePreimageClaimableHtlc?: MaybePreimageClaimableHTLC | undefined;
  counterpartyRevokedOutputClaimable?: CounterpartyRevokedOutputClaimable | undefined;
}

export interface PendingBroadcast {
  channelId: string;
  amountSatoshis: number;
}

export interface BroadcastAwaitingConfirmation {
  channelId?: string | undefined;
  latestBroadcastHeight: number;
  latestSpendingTxid: string;
  amountSatoshis: number;
}

export interface AwaitingThresholdConfirmations {
  channelId?: string | undefined;
  latestSpendingTxid: string;
  confirmationHash: string;
  confirmationHeight: number;
  amountSatoshis: number;
}

export interface PendingSweepBalance {
  pendingBroadcast?: PendingBroadcast | undefined;
  broadcastAwaitingConfirmation?: BroadcastAwaitingConfirmation | undefined;
  awaitingThresholdConfirmations?: AwaitingThresholdConfirmations | undefined;
}

export interface GetBalancesRequest {
}

export interface GetBalancesResponse {
  /** The total balance of our on-chain wallet. */
  totalOnchainBalanceSats: number;
  /**
   * The currently spendable balance of our on-chain wallet.
   * This includes any sufficiently confirmed funds, minus
   * total_anchor_channels_reserve_sats.
   */
  spendableOnchainBalanceSats: number;
  /**
   * The share of our total balance that we retain as an emergency reserve to (hopefully) be
   * able to spend the Anchor outputs when one of our channels is closed.
   */
  totalAnchorChannelsReserveSats: number;
  /**
   * The total balance that we would be able to claim across all our Lightning channels.
   * Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
   * waiting for a preimage or for a timeout to expire). These balances will however be included
   * as MaybePreimageClaimableHTLC and MaybeTimeoutClaimableHTLC in lightning_balances.
   */
  totalLightningBalanceSats: number;
  /**
   * A detailed list of all known Lightning balances that would be claimable on channel closure.
   * Note that less than the listed amounts are spendable over lightning as further reserve
   * restrictions apply. Please refer to ChannelDetails::outbound_capacity_msat and
   * ChannelDetails::next_outbound_htlc_limit_msat as returned by Node::list_channels
   * for a better approximation of the spendable amounts.
   */
  lightningBalances: LightningBalance[];
  /**
   * A detailed list of balances currently being swept from the Lightning to the on-chain
   * wallet.
   * These are balances resulting from channel closures that may have been encumbered by a
   * delay, but are now being claimed and useable once sufficiently confirmed on-chain.
   * Note that, depending on the sync status of the wallets, swept balances listed here might or
   * might not already be accounted for in total_onchain_balance_sats.
   */
  pendingBalancesFromChannelClosures: PendingSweepBalance[];
}

export interface PaymentDetails {
  id: PaymentId | undefined;
  kind: PaymentKind | undefined;
  amountMsat?: number | undefined;
  direction: PaymentDirection;
  status: PaymentStatus;
  latestUpdateTimestamp: number;
}

export interface PaymentKind {
  onchain?: Onchain | undefined;
  bolt11?: Bolt11 | undefined;
  bolt11Jit?: Bolt11Jit | undefined;
  bolt12offer?: Bolt12Offer | undefined;
  bolt12refund?: Bolt12Refund | undefined;
  spontaneous?: Spontaneous | undefined;
}

export interface Onchain {
}

export interface Bolt11 {
  hash: string;
  preimage?: string | undefined;
  secret?: Uint8Array | undefined;
}

export interface Bolt11Jit {
  hash: string;
  preimage?: string | undefined;
  secret?: Uint8Array | undefined;
  lspFeeLimits: LSPFeeLimits | undefined;
}

export interface Bolt12Offer {
  hash?: string | undefined;
  preimage?: string | undefined;
  secret?: Uint8Array | undefined;
  offerId: Uint8Array;
}

export interface Bolt12Refund {
  hash?: string | undefined;
  preimage?: string | undefined;
  secret?: Uint8Array | undefined;
}

export interface Spontaneous {
  hash: string;
  preimage?: string | undefined;
}

export interface LSPFeeLimits {
  maxTotalOpeningFeeMsat?: number | undefined;
  maxProportionalOpeningFeePpmMsat?: number | undefined;
}

export interface PaymentsHistoryRequest {
}

export interface PaymentsHistoryResponse {
  payments: PaymentDetails[];
}

export interface GetPaymentDetailsRequest {
  paymentId: string;
}

export interface GetPaymentDetailsResponse {
  payment: PaymentDetails | undefined;
}

function createBaseGetNodeIdRequest(): GetNodeIdRequest {
  return {};
}

export const GetNodeIdRequest = {
  encode(_: GetNodeIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNodeIdRequest {
    return {};
  },

  toJSON(_: GetNodeIdRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeIdRequest>, I>>(base?: I): GetNodeIdRequest {
    return GetNodeIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeIdRequest>, I>>(_: I): GetNodeIdRequest {
    const message = createBaseGetNodeIdRequest();
    return message;
  },
};

function createBaseGetNodeIdResponse(): GetNodeIdResponse {
  return { nodeId: "" };
}

export const GetNodeIdResponse = {
  encode(message: GetNodeIdResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeIdResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeIdResponse {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: GetNodeIdResponse): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeIdResponse>, I>>(base?: I): GetNodeIdResponse {
    return GetNodeIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeIdResponse>, I>>(object: I): GetNodeIdResponse {
    const message = createBaseGetNodeIdResponse();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseGetNodeStatusRequest(): GetNodeStatusRequest {
  return {};
}

export const GetNodeStatusRequest = {
  encode(_: GetNodeStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNodeStatusRequest {
    return {};
  },

  toJSON(_: GetNodeStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeStatusRequest>, I>>(base?: I): GetNodeStatusRequest {
    return GetNodeStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeStatusRequest>, I>>(_: I): GetNodeStatusRequest {
    const message = createBaseGetNodeStatusRequest();
    return message;
  },
};

function createBaseGetNodeStatusResponse(): GetNodeStatusResponse {
  return {
    publicKey: "",
    currentBestBlock: undefined,
    latestWalletSyncTimestamp: undefined,
    latestOnchainWalletSyncTimestamp: undefined,
    latestFeeRateCacheUpdateTimestamp: undefined,
    latestRgsSnapshotTimestamp: undefined,
    latestNodeAnnouncementBroadcastTimestamp: undefined,
  };
}

export const GetNodeStatusResponse = {
  encode(message: GetNodeStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.currentBestBlock !== undefined) {
      BestBlock.encode(message.currentBestBlock, writer.uint32(18).fork()).ldelim();
    }
    if (message.latestWalletSyncTimestamp !== undefined) {
      writer.uint32(24).uint64(message.latestWalletSyncTimestamp);
    }
    if (message.latestOnchainWalletSyncTimestamp !== undefined) {
      writer.uint32(32).uint64(message.latestOnchainWalletSyncTimestamp);
    }
    if (message.latestFeeRateCacheUpdateTimestamp !== undefined) {
      writer.uint32(40).uint64(message.latestFeeRateCacheUpdateTimestamp);
    }
    if (message.latestRgsSnapshotTimestamp !== undefined) {
      writer.uint32(48).uint64(message.latestRgsSnapshotTimestamp);
    }
    if (message.latestNodeAnnouncementBroadcastTimestamp !== undefined) {
      writer.uint32(56).uint64(message.latestNodeAnnouncementBroadcastTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currentBestBlock = BestBlock.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.latestWalletSyncTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.latestOnchainWalletSyncTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.latestFeeRateCacheUpdateTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.latestRgsSnapshotTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.latestNodeAnnouncementBroadcastTimestamp = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeStatusResponse {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      currentBestBlock: isSet(object.currentBestBlock) ? BestBlock.fromJSON(object.currentBestBlock) : undefined,
      latestWalletSyncTimestamp: isSet(object.latestWalletSyncTimestamp)
        ? globalThis.Number(object.latestWalletSyncTimestamp)
        : undefined,
      latestOnchainWalletSyncTimestamp: isSet(object.latestOnchainWalletSyncTimestamp)
        ? globalThis.Number(object.latestOnchainWalletSyncTimestamp)
        : undefined,
      latestFeeRateCacheUpdateTimestamp: isSet(object.latestFeeRateCacheUpdateTimestamp)
        ? globalThis.Number(object.latestFeeRateCacheUpdateTimestamp)
        : undefined,
      latestRgsSnapshotTimestamp: isSet(object.latestRgsSnapshotTimestamp)
        ? globalThis.Number(object.latestRgsSnapshotTimestamp)
        : undefined,
      latestNodeAnnouncementBroadcastTimestamp: isSet(object.latestNodeAnnouncementBroadcastTimestamp)
        ? globalThis.Number(object.latestNodeAnnouncementBroadcastTimestamp)
        : undefined,
    };
  },

  toJSON(message: GetNodeStatusResponse): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.currentBestBlock !== undefined) {
      obj.currentBestBlock = BestBlock.toJSON(message.currentBestBlock);
    }
    if (message.latestWalletSyncTimestamp !== undefined) {
      obj.latestWalletSyncTimestamp = Math.round(message.latestWalletSyncTimestamp);
    }
    if (message.latestOnchainWalletSyncTimestamp !== undefined) {
      obj.latestOnchainWalletSyncTimestamp = Math.round(message.latestOnchainWalletSyncTimestamp);
    }
    if (message.latestFeeRateCacheUpdateTimestamp !== undefined) {
      obj.latestFeeRateCacheUpdateTimestamp = Math.round(message.latestFeeRateCacheUpdateTimestamp);
    }
    if (message.latestRgsSnapshotTimestamp !== undefined) {
      obj.latestRgsSnapshotTimestamp = Math.round(message.latestRgsSnapshotTimestamp);
    }
    if (message.latestNodeAnnouncementBroadcastTimestamp !== undefined) {
      obj.latestNodeAnnouncementBroadcastTimestamp = Math.round(message.latestNodeAnnouncementBroadcastTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeStatusResponse>, I>>(base?: I): GetNodeStatusResponse {
    return GetNodeStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeStatusResponse>, I>>(object: I): GetNodeStatusResponse {
    const message = createBaseGetNodeStatusResponse();
    message.publicKey = object.publicKey ?? "";
    message.currentBestBlock = (object.currentBestBlock !== undefined && object.currentBestBlock !== null)
      ? BestBlock.fromPartial(object.currentBestBlock)
      : undefined;
    message.latestWalletSyncTimestamp = object.latestWalletSyncTimestamp ?? undefined;
    message.latestOnchainWalletSyncTimestamp = object.latestOnchainWalletSyncTimestamp ?? undefined;
    message.latestFeeRateCacheUpdateTimestamp = object.latestFeeRateCacheUpdateTimestamp ?? undefined;
    message.latestRgsSnapshotTimestamp = object.latestRgsSnapshotTimestamp ?? undefined;
    message.latestNodeAnnouncementBroadcastTimestamp = object.latestNodeAnnouncementBroadcastTimestamp ?? undefined;
    return message;
  },
};

function createBaseBestBlock(): BestBlock {
  return { blockHash: "", height: 0 };
}

export const BestBlock = {
  encode(message: BestBlock, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BestBlock {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBestBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BestBlock {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: BestBlock): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BestBlock>, I>>(base?: I): BestBlock {
    return BestBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BestBlock>, I>>(object: I): BestBlock {
    const message = createBaseBestBlock();
    message.blockHash = object.blockHash ?? "";
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseOnchainReceiveRequest(): OnchainReceiveRequest {
  return {};
}

export const OnchainReceiveRequest = {
  encode(_: OnchainReceiveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnchainReceiveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchainReceiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OnchainReceiveRequest {
    return {};
  },

  toJSON(_: OnchainReceiveRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OnchainReceiveRequest>, I>>(base?: I): OnchainReceiveRequest {
    return OnchainReceiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnchainReceiveRequest>, I>>(_: I): OnchainReceiveRequest {
    const message = createBaseOnchainReceiveRequest();
    return message;
  },
};

function createBaseOnchainReceiveResponse(): OnchainReceiveResponse {
  return { address: "" };
}

export const OnchainReceiveResponse = {
  encode(message: OnchainReceiveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnchainReceiveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchainReceiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnchainReceiveResponse {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: OnchainReceiveResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnchainReceiveResponse>, I>>(base?: I): OnchainReceiveResponse {
    return OnchainReceiveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnchainReceiveResponse>, I>>(object: I): OnchainReceiveResponse {
    const message = createBaseOnchainReceiveResponse();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseOnchainSendRequest(): OnchainSendRequest {
  return { address: "", amountSats: undefined };
}

export const OnchainSendRequest = {
  encode(message: OnchainSendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.amountSats !== undefined) {
      writer.uint32(16).uint64(message.amountSats);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnchainSendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchainSendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountSats = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnchainSendRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amountSats: isSet(object.amountSats) ? globalThis.Number(object.amountSats) : undefined,
    };
  },

  toJSON(message: OnchainSendRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.amountSats !== undefined) {
      obj.amountSats = Math.round(message.amountSats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnchainSendRequest>, I>>(base?: I): OnchainSendRequest {
    return OnchainSendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnchainSendRequest>, I>>(object: I): OnchainSendRequest {
    const message = createBaseOnchainSendRequest();
    message.address = object.address ?? "";
    message.amountSats = object.amountSats ?? undefined;
    return message;
  },
};

function createBaseOnchainSendResponse(): OnchainSendResponse {
  return { txid: "" };
}

export const OnchainSendResponse = {
  encode(message: OnchainSendResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnchainSendResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchainSendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnchainSendResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: OnchainSendResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnchainSendResponse>, I>>(base?: I): OnchainSendResponse {
    return OnchainSendResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnchainSendResponse>, I>>(object: I): OnchainSendResponse {
    const message = createBaseOnchainSendResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseBolt11ReceiveRequest(): Bolt11ReceiveRequest {
  return { description: "", expirySecs: 0, amountMsat: undefined };
}

export const Bolt11ReceiveRequest = {
  encode(message: Bolt11ReceiveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.expirySecs !== 0) {
      writer.uint32(16).uint32(message.expirySecs);
    }
    if (message.amountMsat !== undefined) {
      writer.uint32(24).uint64(message.amountMsat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11ReceiveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11ReceiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expirySecs = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountMsat = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11ReceiveRequest {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      expirySecs: isSet(object.expirySecs) ? globalThis.Number(object.expirySecs) : 0,
      amountMsat: isSet(object.amountMsat) ? globalThis.Number(object.amountMsat) : undefined,
    };
  },

  toJSON(message: Bolt11ReceiveRequest): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.expirySecs !== 0) {
      obj.expirySecs = Math.round(message.expirySecs);
    }
    if (message.amountMsat !== undefined) {
      obj.amountMsat = Math.round(message.amountMsat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11ReceiveRequest>, I>>(base?: I): Bolt11ReceiveRequest {
    return Bolt11ReceiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11ReceiveRequest>, I>>(object: I): Bolt11ReceiveRequest {
    const message = createBaseBolt11ReceiveRequest();
    message.description = object.description ?? "";
    message.expirySecs = object.expirySecs ?? 0;
    message.amountMsat = object.amountMsat ?? undefined;
    return message;
  },
};

function createBaseBolt11ReceiveResponse(): Bolt11ReceiveResponse {
  return { invoice: "" };
}

export const Bolt11ReceiveResponse = {
  encode(message: Bolt11ReceiveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invoice !== "") {
      writer.uint32(10).string(message.invoice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11ReceiveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11ReceiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoice = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11ReceiveResponse {
    return { invoice: isSet(object.invoice) ? globalThis.String(object.invoice) : "" };
  },

  toJSON(message: Bolt11ReceiveResponse): unknown {
    const obj: any = {};
    if (message.invoice !== "") {
      obj.invoice = message.invoice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11ReceiveResponse>, I>>(base?: I): Bolt11ReceiveResponse {
    return Bolt11ReceiveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11ReceiveResponse>, I>>(object: I): Bolt11ReceiveResponse {
    const message = createBaseBolt11ReceiveResponse();
    message.invoice = object.invoice ?? "";
    return message;
  },
};

function createBaseBolt11SendRequest(): Bolt11SendRequest {
  return { invoice: "", amountMsat: undefined };
}

export const Bolt11SendRequest = {
  encode(message: Bolt11SendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invoice !== "") {
      writer.uint32(10).string(message.invoice);
    }
    if (message.amountMsat !== undefined) {
      writer.uint32(16).uint64(message.amountMsat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11SendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11SendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoice = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountMsat = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11SendRequest {
    return {
      invoice: isSet(object.invoice) ? globalThis.String(object.invoice) : "",
      amountMsat: isSet(object.amountMsat) ? globalThis.Number(object.amountMsat) : undefined,
    };
  },

  toJSON(message: Bolt11SendRequest): unknown {
    const obj: any = {};
    if (message.invoice !== "") {
      obj.invoice = message.invoice;
    }
    if (message.amountMsat !== undefined) {
      obj.amountMsat = Math.round(message.amountMsat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11SendRequest>, I>>(base?: I): Bolt11SendRequest {
    return Bolt11SendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11SendRequest>, I>>(object: I): Bolt11SendRequest {
    const message = createBaseBolt11SendRequest();
    message.invoice = object.invoice ?? "";
    message.amountMsat = object.amountMsat ?? undefined;
    return message;
  },
};

function createBaseBolt11SendResponse(): Bolt11SendResponse {
  return { paymentId: undefined };
}

export const Bolt11SendResponse = {
  encode(message: Bolt11SendResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.paymentId !== undefined) {
      PaymentId.encode(message.paymentId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11SendResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11SendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentId = PaymentId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11SendResponse {
    return { paymentId: isSet(object.paymentId) ? PaymentId.fromJSON(object.paymentId) : undefined };
  },

  toJSON(message: Bolt11SendResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== undefined) {
      obj.paymentId = PaymentId.toJSON(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11SendResponse>, I>>(base?: I): Bolt11SendResponse {
    return Bolt11SendResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11SendResponse>, I>>(object: I): Bolt11SendResponse {
    const message = createBaseBolt11SendResponse();
    message.paymentId = (object.paymentId !== undefined && object.paymentId !== null)
      ? PaymentId.fromPartial(object.paymentId)
      : undefined;
    return message;
  },
};

function createBaseBolt12ReceiveRequest(): Bolt12ReceiveRequest {
  return { description: "", amountMsat: undefined };
}

export const Bolt12ReceiveRequest = {
  encode(message: Bolt12ReceiveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.amountMsat !== undefined) {
      writer.uint32(16).uint64(message.amountMsat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12ReceiveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12ReceiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountMsat = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12ReceiveRequest {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      amountMsat: isSet(object.amountMsat) ? globalThis.Number(object.amountMsat) : undefined,
    };
  },

  toJSON(message: Bolt12ReceiveRequest): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.amountMsat !== undefined) {
      obj.amountMsat = Math.round(message.amountMsat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12ReceiveRequest>, I>>(base?: I): Bolt12ReceiveRequest {
    return Bolt12ReceiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12ReceiveRequest>, I>>(object: I): Bolt12ReceiveRequest {
    const message = createBaseBolt12ReceiveRequest();
    message.description = object.description ?? "";
    message.amountMsat = object.amountMsat ?? undefined;
    return message;
  },
};

function createBaseBolt12ReceiveResponse(): Bolt12ReceiveResponse {
  return { offer: "" };
}

export const Bolt12ReceiveResponse = {
  encode(message: Bolt12ReceiveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offer !== "") {
      writer.uint32(10).string(message.offer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12ReceiveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12ReceiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12ReceiveResponse {
    return { offer: isSet(object.offer) ? globalThis.String(object.offer) : "" };
  },

  toJSON(message: Bolt12ReceiveResponse): unknown {
    const obj: any = {};
    if (message.offer !== "") {
      obj.offer = message.offer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12ReceiveResponse>, I>>(base?: I): Bolt12ReceiveResponse {
    return Bolt12ReceiveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12ReceiveResponse>, I>>(object: I): Bolt12ReceiveResponse {
    const message = createBaseBolt12ReceiveResponse();
    message.offer = object.offer ?? "";
    return message;
  },
};

function createBaseBolt12SendRequest(): Bolt12SendRequest {
  return { offer: "", amountMsat: undefined, payerNote: undefined };
}

export const Bolt12SendRequest = {
  encode(message: Bolt12SendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offer !== "") {
      writer.uint32(10).string(message.offer);
    }
    if (message.amountMsat !== undefined) {
      writer.uint32(16).uint64(message.amountMsat);
    }
    if (message.payerNote !== undefined) {
      writer.uint32(26).string(message.payerNote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12SendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12SendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offer = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payerNote = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12SendRequest {
    return {
      offer: isSet(object.offer) ? globalThis.String(object.offer) : "",
      amountMsat: isSet(object.amountMsat) ? globalThis.Number(object.amountMsat) : undefined,
      payerNote: isSet(object.payerNote) ? globalThis.String(object.payerNote) : undefined,
    };
  },

  toJSON(message: Bolt12SendRequest): unknown {
    const obj: any = {};
    if (message.offer !== "") {
      obj.offer = message.offer;
    }
    if (message.amountMsat !== undefined) {
      obj.amountMsat = Math.round(message.amountMsat);
    }
    if (message.payerNote !== undefined) {
      obj.payerNote = message.payerNote;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12SendRequest>, I>>(base?: I): Bolt12SendRequest {
    return Bolt12SendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12SendRequest>, I>>(object: I): Bolt12SendRequest {
    const message = createBaseBolt12SendRequest();
    message.offer = object.offer ?? "";
    message.amountMsat = object.amountMsat ?? undefined;
    message.payerNote = object.payerNote ?? undefined;
    return message;
  },
};

function createBaseBolt12SendResponse(): Bolt12SendResponse {
  return { paymentId: undefined };
}

export const Bolt12SendResponse = {
  encode(message: Bolt12SendResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.paymentId !== undefined) {
      PaymentId.encode(message.paymentId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12SendResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12SendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentId = PaymentId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12SendResponse {
    return { paymentId: isSet(object.paymentId) ? PaymentId.fromJSON(object.paymentId) : undefined };
  },

  toJSON(message: Bolt12SendResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== undefined) {
      obj.paymentId = PaymentId.toJSON(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12SendResponse>, I>>(base?: I): Bolt12SendResponse {
    return Bolt12SendResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12SendResponse>, I>>(object: I): Bolt12SendResponse {
    const message = createBaseBolt12SendResponse();
    message.paymentId = (object.paymentId !== undefined && object.paymentId !== null)
      ? PaymentId.fromPartial(object.paymentId)
      : undefined;
    return message;
  },
};

function createBasePaymentId(): PaymentId {
  return { data: new Uint8Array(0) };
}

export const PaymentId = {
  encode(message: PaymentId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentId {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: PaymentId): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentId>, I>>(base?: I): PaymentId {
    return PaymentId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentId>, I>>(object: I): PaymentId {
    const message = createBasePaymentId();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListChannelsRequest(): ListChannelsRequest {
  return {};
}

export const ListChannelsRequest = {
  encode(_: ListChannelsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListChannelsRequest {
    return {};
  },

  toJSON(_: ListChannelsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelsRequest>, I>>(base?: I): ListChannelsRequest {
    return ListChannelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelsRequest>, I>>(_: I): ListChannelsRequest {
    const message = createBaseListChannelsRequest();
    return message;
  },
};

function createBaseListChannelsResponse(): ListChannelsResponse {
  return { channels: [] };
}

export const ListChannelsResponse = {
  encode(message: ListChannelsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channels) {
      Channel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channels.push(Channel.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelsResponse {
    return {
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e: any) => Channel.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListChannelsResponse): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => Channel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelsResponse>, I>>(base?: I): ListChannelsResponse {
    return ListChannelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelsResponse>, I>>(object: I): ListChannelsResponse {
    const message = createBaseListChannelsResponse();
    message.channels = object.channels?.map((e) => Channel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOpenChannelRequest(): OpenChannelRequest {
  return { nodeId: "", address: "", channelAmountSats: 0, pushToCounterpartyMsat: undefined, announceChannel: false };
}

export const OpenChannelRequest = {
  encode(message: OpenChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.channelAmountSats !== 0) {
      writer.uint32(24).uint64(message.channelAmountSats);
    }
    if (message.pushToCounterpartyMsat !== undefined) {
      writer.uint32(32).uint64(message.pushToCounterpartyMsat);
    }
    if (message.announceChannel !== false) {
      writer.uint32(40).bool(message.announceChannel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OpenChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channelAmountSats = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pushToCounterpartyMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.announceChannel = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenChannelRequest {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      channelAmountSats: isSet(object.channelAmountSats) ? globalThis.Number(object.channelAmountSats) : 0,
      pushToCounterpartyMsat: isSet(object.pushToCounterpartyMsat)
        ? globalThis.Number(object.pushToCounterpartyMsat)
        : undefined,
      announceChannel: isSet(object.announceChannel) ? globalThis.Boolean(object.announceChannel) : false,
    };
  },

  toJSON(message: OpenChannelRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.channelAmountSats !== 0) {
      obj.channelAmountSats = Math.round(message.channelAmountSats);
    }
    if (message.pushToCounterpartyMsat !== undefined) {
      obj.pushToCounterpartyMsat = Math.round(message.pushToCounterpartyMsat);
    }
    if (message.announceChannel !== false) {
      obj.announceChannel = message.announceChannel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenChannelRequest>, I>>(base?: I): OpenChannelRequest {
    return OpenChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenChannelRequest>, I>>(object: I): OpenChannelRequest {
    const message = createBaseOpenChannelRequest();
    message.nodeId = object.nodeId ?? "";
    message.address = object.address ?? "";
    message.channelAmountSats = object.channelAmountSats ?? 0;
    message.pushToCounterpartyMsat = object.pushToCounterpartyMsat ?? undefined;
    message.announceChannel = object.announceChannel ?? false;
    return message;
  },
};

function createBaseOpenChannelResponse(): OpenChannelResponse {
  return { userChannelId: new Uint8Array(0) };
}

export const OpenChannelResponse = {
  encode(message: OpenChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userChannelId.length !== 0) {
      writer.uint32(10).bytes(message.userChannelId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OpenChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userChannelId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenChannelResponse {
    return { userChannelId: isSet(object.userChannelId) ? bytesFromBase64(object.userChannelId) : new Uint8Array(0) };
  },

  toJSON(message: OpenChannelResponse): unknown {
    const obj: any = {};
    if (message.userChannelId.length !== 0) {
      obj.userChannelId = base64FromBytes(message.userChannelId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenChannelResponse>, I>>(base?: I): OpenChannelResponse {
    return OpenChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenChannelResponse>, I>>(object: I): OpenChannelResponse {
    const message = createBaseOpenChannelResponse();
    message.userChannelId = object.userChannelId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCloseChannelRequest(): CloseChannelRequest {
  return { userChannelId: new Uint8Array(0), counterpartyNodeId: "" };
}

export const CloseChannelRequest = {
  encode(message: CloseChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userChannelId.length !== 0) {
      writer.uint32(10).bytes(message.userChannelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CloseChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userChannelId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseChannelRequest {
    return {
      userChannelId: isSet(object.userChannelId) ? bytesFromBase64(object.userChannelId) : new Uint8Array(0),
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
    };
  },

  toJSON(message: CloseChannelRequest): unknown {
    const obj: any = {};
    if (message.userChannelId.length !== 0) {
      obj.userChannelId = base64FromBytes(message.userChannelId);
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseChannelRequest>, I>>(base?: I): CloseChannelRequest {
    return CloseChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseChannelRequest>, I>>(object: I): CloseChannelRequest {
    const message = createBaseCloseChannelRequest();
    message.userChannelId = object.userChannelId ?? new Uint8Array(0);
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    return message;
  },
};

function createBaseCloseChannelResponse(): CloseChannelResponse {
  return {};
}

export const CloseChannelResponse = {
  encode(_: CloseChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CloseChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CloseChannelResponse {
    return {};
  },

  toJSON(_: CloseChannelResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseChannelResponse>, I>>(base?: I): CloseChannelResponse {
    return CloseChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseChannelResponse>, I>>(_: I): CloseChannelResponse {
    const message = createBaseCloseChannelResponse();
    return message;
  },
};

function createBaseForceCloseChannelRequest(): ForceCloseChannelRequest {
  return { userChannelId: new Uint8Array(0), counterpartyNodeId: "" };
}

export const ForceCloseChannelRequest = {
  encode(message: ForceCloseChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userChannelId.length !== 0) {
      writer.uint32(10).bytes(message.userChannelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ForceCloseChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceCloseChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userChannelId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceCloseChannelRequest {
    return {
      userChannelId: isSet(object.userChannelId) ? bytesFromBase64(object.userChannelId) : new Uint8Array(0),
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
    };
  },

  toJSON(message: ForceCloseChannelRequest): unknown {
    const obj: any = {};
    if (message.userChannelId.length !== 0) {
      obj.userChannelId = base64FromBytes(message.userChannelId);
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForceCloseChannelRequest>, I>>(base?: I): ForceCloseChannelRequest {
    return ForceCloseChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForceCloseChannelRequest>, I>>(object: I): ForceCloseChannelRequest {
    const message = createBaseForceCloseChannelRequest();
    message.userChannelId = object.userChannelId ?? new Uint8Array(0);
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    return message;
  },
};

function createBaseForceCloseChannelResponse(): ForceCloseChannelResponse {
  return {};
}

export const ForceCloseChannelResponse = {
  encode(_: ForceCloseChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ForceCloseChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceCloseChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ForceCloseChannelResponse {
    return {};
  },

  toJSON(_: ForceCloseChannelResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ForceCloseChannelResponse>, I>>(base?: I): ForceCloseChannelResponse {
    return ForceCloseChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForceCloseChannelResponse>, I>>(_: I): ForceCloseChannelResponse {
    const message = createBaseForceCloseChannelResponse();
    return message;
  },
};

function createBaseChannel(): Channel {
  return {
    channelId: "",
    counterpartyNodeId: "",
    fundingTxo: undefined,
    channelValueSats: 0,
    feerateSatPer1000Weight: 0,
    outboundCapacityMsat: 0,
    inboundCapacityMsat: 0,
    confirmationsRequired: undefined,
    confirmations: undefined,
    isOutbound: false,
    isChannelReady: false,
    isUsable: false,
    isPublic: false,
    cltvExpiryDelta: undefined,
    counterpartyOutboundHtlcMinimumMsat: undefined,
    counterpartyOutboundHtlcMaximumMsat: undefined,
    nextOutboundHtlcLimitMsat: 0,
    nextOutboundHtlcMinimumMsat: 0,
    forceCloseSpendDelay: undefined,
    forwardingFeeProportionalMillionths: 0,
    forwardingFeeBaseMsat: 0,
  };
}

export const Channel = {
  encode(message: Channel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.fundingTxo !== undefined) {
      Outpoint.encode(message.fundingTxo, writer.uint32(26).fork()).ldelim();
    }
    if (message.channelValueSats !== 0) {
      writer.uint32(32).uint64(message.channelValueSats);
    }
    if (message.feerateSatPer1000Weight !== 0) {
      writer.uint32(40).uint32(message.feerateSatPer1000Weight);
    }
    if (message.outboundCapacityMsat !== 0) {
      writer.uint32(48).uint64(message.outboundCapacityMsat);
    }
    if (message.inboundCapacityMsat !== 0) {
      writer.uint32(56).uint64(message.inboundCapacityMsat);
    }
    if (message.confirmationsRequired !== undefined) {
      writer.uint32(64).uint32(message.confirmationsRequired);
    }
    if (message.confirmations !== undefined) {
      writer.uint32(72).uint32(message.confirmations);
    }
    if (message.isOutbound !== false) {
      writer.uint32(80).bool(message.isOutbound);
    }
    if (message.isChannelReady !== false) {
      writer.uint32(88).bool(message.isChannelReady);
    }
    if (message.isUsable !== false) {
      writer.uint32(96).bool(message.isUsable);
    }
    if (message.isPublic !== false) {
      writer.uint32(104).bool(message.isPublic);
    }
    if (message.cltvExpiryDelta !== undefined) {
      writer.uint32(112).uint32(message.cltvExpiryDelta);
    }
    if (message.counterpartyOutboundHtlcMinimumMsat !== undefined) {
      writer.uint32(120).uint64(message.counterpartyOutboundHtlcMinimumMsat);
    }
    if (message.counterpartyOutboundHtlcMaximumMsat !== undefined) {
      writer.uint32(128).uint64(message.counterpartyOutboundHtlcMaximumMsat);
    }
    if (message.nextOutboundHtlcLimitMsat !== 0) {
      writer.uint32(136).uint64(message.nextOutboundHtlcLimitMsat);
    }
    if (message.nextOutboundHtlcMinimumMsat !== 0) {
      writer.uint32(144).uint64(message.nextOutboundHtlcMinimumMsat);
    }
    if (message.forceCloseSpendDelay !== undefined) {
      writer.uint32(152).uint32(message.forceCloseSpendDelay);
    }
    if (message.forwardingFeeProportionalMillionths !== 0) {
      writer.uint32(160).uint32(message.forwardingFeeProportionalMillionths);
    }
    if (message.forwardingFeeBaseMsat !== 0) {
      writer.uint32(168).uint32(message.forwardingFeeBaseMsat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Channel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fundingTxo = Outpoint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.channelValueSats = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.feerateSatPer1000Weight = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.outboundCapacityMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.inboundCapacityMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.confirmationsRequired = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.confirmations = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isOutbound = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isChannelReady = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isUsable = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.cltvExpiryDelta = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.counterpartyOutboundHtlcMinimumMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.counterpartyOutboundHtlcMaximumMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.nextOutboundHtlcLimitMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.nextOutboundHtlcMinimumMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.forceCloseSpendDelay = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.forwardingFeeProportionalMillionths = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.forwardingFeeBaseMsat = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      fundingTxo: isSet(object.fundingTxo) ? Outpoint.fromJSON(object.fundingTxo) : undefined,
      channelValueSats: isSet(object.channelValueSats) ? globalThis.Number(object.channelValueSats) : 0,
      feerateSatPer1000Weight: isSet(object.feerateSatPer1000Weight)
        ? globalThis.Number(object.feerateSatPer1000Weight)
        : 0,
      outboundCapacityMsat: isSet(object.outboundCapacityMsat) ? globalThis.Number(object.outboundCapacityMsat) : 0,
      inboundCapacityMsat: isSet(object.inboundCapacityMsat) ? globalThis.Number(object.inboundCapacityMsat) : 0,
      confirmationsRequired: isSet(object.confirmationsRequired)
        ? globalThis.Number(object.confirmationsRequired)
        : undefined,
      confirmations: isSet(object.confirmations) ? globalThis.Number(object.confirmations) : undefined,
      isOutbound: isSet(object.isOutbound) ? globalThis.Boolean(object.isOutbound) : false,
      isChannelReady: isSet(object.isChannelReady) ? globalThis.Boolean(object.isChannelReady) : false,
      isUsable: isSet(object.isUsable) ? globalThis.Boolean(object.isUsable) : false,
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : false,
      cltvExpiryDelta: isSet(object.cltvExpiryDelta) ? globalThis.Number(object.cltvExpiryDelta) : undefined,
      counterpartyOutboundHtlcMinimumMsat: isSet(object.counterpartyOutboundHtlcMinimumMsat)
        ? globalThis.Number(object.counterpartyOutboundHtlcMinimumMsat)
        : undefined,
      counterpartyOutboundHtlcMaximumMsat: isSet(object.counterpartyOutboundHtlcMaximumMsat)
        ? globalThis.Number(object.counterpartyOutboundHtlcMaximumMsat)
        : undefined,
      nextOutboundHtlcLimitMsat: isSet(object.nextOutboundHtlcLimitMsat)
        ? globalThis.Number(object.nextOutboundHtlcLimitMsat)
        : 0,
      nextOutboundHtlcMinimumMsat: isSet(object.nextOutboundHtlcMinimumMsat)
        ? globalThis.Number(object.nextOutboundHtlcMinimumMsat)
        : 0,
      forceCloseSpendDelay: isSet(object.forceCloseSpendDelay)
        ? globalThis.Number(object.forceCloseSpendDelay)
        : undefined,
      forwardingFeeProportionalMillionths: isSet(object.forwardingFeeProportionalMillionths)
        ? globalThis.Number(object.forwardingFeeProportionalMillionths)
        : 0,
      forwardingFeeBaseMsat: isSet(object.forwardingFeeBaseMsat) ? globalThis.Number(object.forwardingFeeBaseMsat) : 0,
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.fundingTxo !== undefined) {
      obj.fundingTxo = Outpoint.toJSON(message.fundingTxo);
    }
    if (message.channelValueSats !== 0) {
      obj.channelValueSats = Math.round(message.channelValueSats);
    }
    if (message.feerateSatPer1000Weight !== 0) {
      obj.feerateSatPer1000Weight = Math.round(message.feerateSatPer1000Weight);
    }
    if (message.outboundCapacityMsat !== 0) {
      obj.outboundCapacityMsat = Math.round(message.outboundCapacityMsat);
    }
    if (message.inboundCapacityMsat !== 0) {
      obj.inboundCapacityMsat = Math.round(message.inboundCapacityMsat);
    }
    if (message.confirmationsRequired !== undefined) {
      obj.confirmationsRequired = Math.round(message.confirmationsRequired);
    }
    if (message.confirmations !== undefined) {
      obj.confirmations = Math.round(message.confirmations);
    }
    if (message.isOutbound !== false) {
      obj.isOutbound = message.isOutbound;
    }
    if (message.isChannelReady !== false) {
      obj.isChannelReady = message.isChannelReady;
    }
    if (message.isUsable !== false) {
      obj.isUsable = message.isUsable;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    if (message.cltvExpiryDelta !== undefined) {
      obj.cltvExpiryDelta = Math.round(message.cltvExpiryDelta);
    }
    if (message.counterpartyOutboundHtlcMinimumMsat !== undefined) {
      obj.counterpartyOutboundHtlcMinimumMsat = Math.round(message.counterpartyOutboundHtlcMinimumMsat);
    }
    if (message.counterpartyOutboundHtlcMaximumMsat !== undefined) {
      obj.counterpartyOutboundHtlcMaximumMsat = Math.round(message.counterpartyOutboundHtlcMaximumMsat);
    }
    if (message.nextOutboundHtlcLimitMsat !== 0) {
      obj.nextOutboundHtlcLimitMsat = Math.round(message.nextOutboundHtlcLimitMsat);
    }
    if (message.nextOutboundHtlcMinimumMsat !== 0) {
      obj.nextOutboundHtlcMinimumMsat = Math.round(message.nextOutboundHtlcMinimumMsat);
    }
    if (message.forceCloseSpendDelay !== undefined) {
      obj.forceCloseSpendDelay = Math.round(message.forceCloseSpendDelay);
    }
    if (message.forwardingFeeProportionalMillionths !== 0) {
      obj.forwardingFeeProportionalMillionths = Math.round(message.forwardingFeeProportionalMillionths);
    }
    if (message.forwardingFeeBaseMsat !== 0) {
      obj.forwardingFeeBaseMsat = Math.round(message.forwardingFeeBaseMsat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.fundingTxo = (object.fundingTxo !== undefined && object.fundingTxo !== null)
      ? Outpoint.fromPartial(object.fundingTxo)
      : undefined;
    message.channelValueSats = object.channelValueSats ?? 0;
    message.feerateSatPer1000Weight = object.feerateSatPer1000Weight ?? 0;
    message.outboundCapacityMsat = object.outboundCapacityMsat ?? 0;
    message.inboundCapacityMsat = object.inboundCapacityMsat ?? 0;
    message.confirmationsRequired = object.confirmationsRequired ?? undefined;
    message.confirmations = object.confirmations ?? undefined;
    message.isOutbound = object.isOutbound ?? false;
    message.isChannelReady = object.isChannelReady ?? false;
    message.isUsable = object.isUsable ?? false;
    message.isPublic = object.isPublic ?? false;
    message.cltvExpiryDelta = object.cltvExpiryDelta ?? undefined;
    message.counterpartyOutboundHtlcMinimumMsat = object.counterpartyOutboundHtlcMinimumMsat ?? undefined;
    message.counterpartyOutboundHtlcMaximumMsat = object.counterpartyOutboundHtlcMaximumMsat ?? undefined;
    message.nextOutboundHtlcLimitMsat = object.nextOutboundHtlcLimitMsat ?? 0;
    message.nextOutboundHtlcMinimumMsat = object.nextOutboundHtlcMinimumMsat ?? 0;
    message.forceCloseSpendDelay = object.forceCloseSpendDelay ?? undefined;
    message.forwardingFeeProportionalMillionths = object.forwardingFeeProportionalMillionths ?? 0;
    message.forwardingFeeBaseMsat = object.forwardingFeeBaseMsat ?? 0;
    return message;
  },
};

function createBaseOutpoint(): Outpoint {
  return { txid: "", vout: 0 };
}

export const Outpoint = {
  encode(message: Outpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Outpoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Outpoint {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: Outpoint): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Outpoint>, I>>(base?: I): Outpoint {
    return Outpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Outpoint>, I>>(object: I): Outpoint {
    const message = createBaseOutpoint();
    message.txid = object.txid ?? "";
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseClaimableOnChannelClose(): ClaimableOnChannelClose {
  return { channelId: "", counterpartyNodeId: "", amountSatoshis: 0 };
}

export const ClaimableOnChannelClose = {
  encode(message: ClaimableOnChannelClose, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimableOnChannelClose {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimableOnChannelClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimableOnChannelClose {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
    };
  },

  toJSON(message: ClaimableOnChannelClose): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimableOnChannelClose>, I>>(base?: I): ClaimableOnChannelClose {
    return ClaimableOnChannelClose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimableOnChannelClose>, I>>(object: I): ClaimableOnChannelClose {
    const message = createBaseClaimableOnChannelClose();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    return message;
  },
};

function createBaseClaimableAwaitingConfirmations(): ClaimableAwaitingConfirmations {
  return { channelId: "", counterpartyNodeId: "", amountSatoshis: 0, confirmationHeight: 0 };
}

export const ClaimableAwaitingConfirmations = {
  encode(message: ClaimableAwaitingConfirmations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    if (message.confirmationHeight !== 0) {
      writer.uint32(32).uint32(message.confirmationHeight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimableAwaitingConfirmations {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimableAwaitingConfirmations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.confirmationHeight = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimableAwaitingConfirmations {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
      confirmationHeight: isSet(object.confirmationHeight) ? globalThis.Number(object.confirmationHeight) : 0,
    };
  },

  toJSON(message: ClaimableAwaitingConfirmations): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    if (message.confirmationHeight !== 0) {
      obj.confirmationHeight = Math.round(message.confirmationHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimableAwaitingConfirmations>, I>>(base?: I): ClaimableAwaitingConfirmations {
    return ClaimableAwaitingConfirmations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimableAwaitingConfirmations>, I>>(
    object: I,
  ): ClaimableAwaitingConfirmations {
    const message = createBaseClaimableAwaitingConfirmations();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    message.confirmationHeight = object.confirmationHeight ?? 0;
    return message;
  },
};

function createBaseContentiousClaimable(): ContentiousClaimable {
  return {
    channelId: "",
    counterpartyNodeId: "",
    amountSatoshis: 0,
    timeoutHeight: 0,
    paymentHash: "",
    paymentPreimage: "",
  };
}

export const ContentiousClaimable = {
  encode(message: ContentiousClaimable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    if (message.timeoutHeight !== 0) {
      writer.uint32(32).uint32(message.timeoutHeight);
    }
    if (message.paymentHash !== "") {
      writer.uint32(42).string(message.paymentHash);
    }
    if (message.paymentPreimage !== "") {
      writer.uint32(50).string(message.paymentPreimage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContentiousClaimable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentiousClaimable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutHeight = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paymentPreimage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentiousClaimable {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
      timeoutHeight: isSet(object.timeoutHeight) ? globalThis.Number(object.timeoutHeight) : 0,
      paymentHash: isSet(object.paymentHash) ? globalThis.String(object.paymentHash) : "",
      paymentPreimage: isSet(object.paymentPreimage) ? globalThis.String(object.paymentPreimage) : "",
    };
  },

  toJSON(message: ContentiousClaimable): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    if (message.timeoutHeight !== 0) {
      obj.timeoutHeight = Math.round(message.timeoutHeight);
    }
    if (message.paymentHash !== "") {
      obj.paymentHash = message.paymentHash;
    }
    if (message.paymentPreimage !== "") {
      obj.paymentPreimage = message.paymentPreimage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentiousClaimable>, I>>(base?: I): ContentiousClaimable {
    return ContentiousClaimable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentiousClaimable>, I>>(object: I): ContentiousClaimable {
    const message = createBaseContentiousClaimable();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    message.timeoutHeight = object.timeoutHeight ?? 0;
    message.paymentHash = object.paymentHash ?? "";
    message.paymentPreimage = object.paymentPreimage ?? "";
    return message;
  },
};

function createBaseMaybeTimeoutClaimableHTLC(): MaybeTimeoutClaimableHTLC {
  return { channelId: "", counterpartyNodeId: "", amountSatoshis: 0, claimableHeight: 0, paymentHash: "" };
}

export const MaybeTimeoutClaimableHTLC = {
  encode(message: MaybeTimeoutClaimableHTLC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    if (message.claimableHeight !== 0) {
      writer.uint32(32).uint32(message.claimableHeight);
    }
    if (message.paymentHash !== "") {
      writer.uint32(42).string(message.paymentHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MaybeTimeoutClaimableHTLC {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaybeTimeoutClaimableHTLC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.claimableHeight = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaybeTimeoutClaimableHTLC {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
      claimableHeight: isSet(object.claimableHeight) ? globalThis.Number(object.claimableHeight) : 0,
      paymentHash: isSet(object.paymentHash) ? globalThis.String(object.paymentHash) : "",
    };
  },

  toJSON(message: MaybeTimeoutClaimableHTLC): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    if (message.claimableHeight !== 0) {
      obj.claimableHeight = Math.round(message.claimableHeight);
    }
    if (message.paymentHash !== "") {
      obj.paymentHash = message.paymentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MaybeTimeoutClaimableHTLC>, I>>(base?: I): MaybeTimeoutClaimableHTLC {
    return MaybeTimeoutClaimableHTLC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MaybeTimeoutClaimableHTLC>, I>>(object: I): MaybeTimeoutClaimableHTLC {
    const message = createBaseMaybeTimeoutClaimableHTLC();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    message.claimableHeight = object.claimableHeight ?? 0;
    message.paymentHash = object.paymentHash ?? "";
    return message;
  },
};

function createBaseMaybePreimageClaimableHTLC(): MaybePreimageClaimableHTLC {
  return { channelId: "", counterpartyNodeId: "", amountSatoshis: 0, expiryHeight: 0, paymentHash: "" };
}

export const MaybePreimageClaimableHTLC = {
  encode(message: MaybePreimageClaimableHTLC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    if (message.expiryHeight !== 0) {
      writer.uint32(32).uint32(message.expiryHeight);
    }
    if (message.paymentHash !== "") {
      writer.uint32(42).string(message.paymentHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MaybePreimageClaimableHTLC {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaybePreimageClaimableHTLC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expiryHeight = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaybePreimageClaimableHTLC {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
      expiryHeight: isSet(object.expiryHeight) ? globalThis.Number(object.expiryHeight) : 0,
      paymentHash: isSet(object.paymentHash) ? globalThis.String(object.paymentHash) : "",
    };
  },

  toJSON(message: MaybePreimageClaimableHTLC): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    if (message.expiryHeight !== 0) {
      obj.expiryHeight = Math.round(message.expiryHeight);
    }
    if (message.paymentHash !== "") {
      obj.paymentHash = message.paymentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MaybePreimageClaimableHTLC>, I>>(base?: I): MaybePreimageClaimableHTLC {
    return MaybePreimageClaimableHTLC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MaybePreimageClaimableHTLC>, I>>(object: I): MaybePreimageClaimableHTLC {
    const message = createBaseMaybePreimageClaimableHTLC();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    message.expiryHeight = object.expiryHeight ?? 0;
    message.paymentHash = object.paymentHash ?? "";
    return message;
  },
};

function createBaseCounterpartyRevokedOutputClaimable(): CounterpartyRevokedOutputClaimable {
  return { channelId: "", counterpartyNodeId: "", amountSatoshis: 0 };
}

export const CounterpartyRevokedOutputClaimable = {
  encode(message: CounterpartyRevokedOutputClaimable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterpartyNodeId !== "") {
      writer.uint32(18).string(message.counterpartyNodeId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(24).uint64(message.amountSatoshis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CounterpartyRevokedOutputClaimable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterpartyRevokedOutputClaimable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counterpartyNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterpartyRevokedOutputClaimable {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterpartyNodeId: isSet(object.counterpartyNodeId) ? globalThis.String(object.counterpartyNodeId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
    };
  },

  toJSON(message: CounterpartyRevokedOutputClaimable): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterpartyNodeId !== "") {
      obj.counterpartyNodeId = message.counterpartyNodeId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CounterpartyRevokedOutputClaimable>, I>>(
    base?: I,
  ): CounterpartyRevokedOutputClaimable {
    return CounterpartyRevokedOutputClaimable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CounterpartyRevokedOutputClaimable>, I>>(
    object: I,
  ): CounterpartyRevokedOutputClaimable {
    const message = createBaseCounterpartyRevokedOutputClaimable();
    message.channelId = object.channelId ?? "";
    message.counterpartyNodeId = object.counterpartyNodeId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    return message;
  },
};

function createBaseLightningBalance(): LightningBalance {
  return {
    claimableOnChannelClose: undefined,
    claimableAwaitingConfirmations: undefined,
    contentiousClaimable: undefined,
    maybeTimeoutClaimableHtlc: undefined,
    maybePreimageClaimableHtlc: undefined,
    counterpartyRevokedOutputClaimable: undefined,
  };
}

export const LightningBalance = {
  encode(message: LightningBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.claimableOnChannelClose !== undefined) {
      ClaimableOnChannelClose.encode(message.claimableOnChannelClose, writer.uint32(10).fork()).ldelim();
    }
    if (message.claimableAwaitingConfirmations !== undefined) {
      ClaimableAwaitingConfirmations.encode(message.claimableAwaitingConfirmations, writer.uint32(18).fork()).ldelim();
    }
    if (message.contentiousClaimable !== undefined) {
      ContentiousClaimable.encode(message.contentiousClaimable, writer.uint32(26).fork()).ldelim();
    }
    if (message.maybeTimeoutClaimableHtlc !== undefined) {
      MaybeTimeoutClaimableHTLC.encode(message.maybeTimeoutClaimableHtlc, writer.uint32(34).fork()).ldelim();
    }
    if (message.maybePreimageClaimableHtlc !== undefined) {
      MaybePreimageClaimableHTLC.encode(message.maybePreimageClaimableHtlc, writer.uint32(42).fork()).ldelim();
    }
    if (message.counterpartyRevokedOutputClaimable !== undefined) {
      CounterpartyRevokedOutputClaimable.encode(message.counterpartyRevokedOutputClaimable, writer.uint32(50).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LightningBalance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLightningBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.claimableOnChannelClose = ClaimableOnChannelClose.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimableAwaitingConfirmations = ClaimableAwaitingConfirmations.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentiousClaimable = ContentiousClaimable.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maybeTimeoutClaimableHtlc = MaybeTimeoutClaimableHTLC.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maybePreimageClaimableHtlc = MaybePreimageClaimableHTLC.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.counterpartyRevokedOutputClaimable = CounterpartyRevokedOutputClaimable.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LightningBalance {
    return {
      claimableOnChannelClose: isSet(object.claimableOnChannelClose)
        ? ClaimableOnChannelClose.fromJSON(object.claimableOnChannelClose)
        : undefined,
      claimableAwaitingConfirmations: isSet(object.claimableAwaitingConfirmations)
        ? ClaimableAwaitingConfirmations.fromJSON(object.claimableAwaitingConfirmations)
        : undefined,
      contentiousClaimable: isSet(object.contentiousClaimable)
        ? ContentiousClaimable.fromJSON(object.contentiousClaimable)
        : undefined,
      maybeTimeoutClaimableHtlc: isSet(object.maybeTimeoutClaimableHtlc)
        ? MaybeTimeoutClaimableHTLC.fromJSON(object.maybeTimeoutClaimableHtlc)
        : undefined,
      maybePreimageClaimableHtlc: isSet(object.maybePreimageClaimableHtlc)
        ? MaybePreimageClaimableHTLC.fromJSON(object.maybePreimageClaimableHtlc)
        : undefined,
      counterpartyRevokedOutputClaimable: isSet(object.counterpartyRevokedOutputClaimable)
        ? CounterpartyRevokedOutputClaimable.fromJSON(object.counterpartyRevokedOutputClaimable)
        : undefined,
    };
  },

  toJSON(message: LightningBalance): unknown {
    const obj: any = {};
    if (message.claimableOnChannelClose !== undefined) {
      obj.claimableOnChannelClose = ClaimableOnChannelClose.toJSON(message.claimableOnChannelClose);
    }
    if (message.claimableAwaitingConfirmations !== undefined) {
      obj.claimableAwaitingConfirmations = ClaimableAwaitingConfirmations.toJSON(
        message.claimableAwaitingConfirmations,
      );
    }
    if (message.contentiousClaimable !== undefined) {
      obj.contentiousClaimable = ContentiousClaimable.toJSON(message.contentiousClaimable);
    }
    if (message.maybeTimeoutClaimableHtlc !== undefined) {
      obj.maybeTimeoutClaimableHtlc = MaybeTimeoutClaimableHTLC.toJSON(message.maybeTimeoutClaimableHtlc);
    }
    if (message.maybePreimageClaimableHtlc !== undefined) {
      obj.maybePreimageClaimableHtlc = MaybePreimageClaimableHTLC.toJSON(message.maybePreimageClaimableHtlc);
    }
    if (message.counterpartyRevokedOutputClaimable !== undefined) {
      obj.counterpartyRevokedOutputClaimable = CounterpartyRevokedOutputClaimable.toJSON(
        message.counterpartyRevokedOutputClaimable,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LightningBalance>, I>>(base?: I): LightningBalance {
    return LightningBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LightningBalance>, I>>(object: I): LightningBalance {
    const message = createBaseLightningBalance();
    message.claimableOnChannelClose =
      (object.claimableOnChannelClose !== undefined && object.claimableOnChannelClose !== null)
        ? ClaimableOnChannelClose.fromPartial(object.claimableOnChannelClose)
        : undefined;
    message.claimableAwaitingConfirmations =
      (object.claimableAwaitingConfirmations !== undefined && object.claimableAwaitingConfirmations !== null)
        ? ClaimableAwaitingConfirmations.fromPartial(object.claimableAwaitingConfirmations)
        : undefined;
    message.contentiousClaimable = (object.contentiousClaimable !== undefined && object.contentiousClaimable !== null)
      ? ContentiousClaimable.fromPartial(object.contentiousClaimable)
      : undefined;
    message.maybeTimeoutClaimableHtlc =
      (object.maybeTimeoutClaimableHtlc !== undefined && object.maybeTimeoutClaimableHtlc !== null)
        ? MaybeTimeoutClaimableHTLC.fromPartial(object.maybeTimeoutClaimableHtlc)
        : undefined;
    message.maybePreimageClaimableHtlc =
      (object.maybePreimageClaimableHtlc !== undefined && object.maybePreimageClaimableHtlc !== null)
        ? MaybePreimageClaimableHTLC.fromPartial(object.maybePreimageClaimableHtlc)
        : undefined;
    message.counterpartyRevokedOutputClaimable =
      (object.counterpartyRevokedOutputClaimable !== undefined && object.counterpartyRevokedOutputClaimable !== null)
        ? CounterpartyRevokedOutputClaimable.fromPartial(object.counterpartyRevokedOutputClaimable)
        : undefined;
    return message;
  },
};

function createBasePendingBroadcast(): PendingBroadcast {
  return { channelId: "", amountSatoshis: 0 };
}

export const PendingBroadcast = {
  encode(message: PendingBroadcast, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(16).uint64(message.amountSatoshis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PendingBroadcast {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingBroadcast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingBroadcast {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
    };
  },

  toJSON(message: PendingBroadcast): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingBroadcast>, I>>(base?: I): PendingBroadcast {
    return PendingBroadcast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingBroadcast>, I>>(object: I): PendingBroadcast {
    const message = createBasePendingBroadcast();
    message.channelId = object.channelId ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    return message;
  },
};

function createBaseBroadcastAwaitingConfirmation(): BroadcastAwaitingConfirmation {
  return { channelId: undefined, latestBroadcastHeight: 0, latestSpendingTxid: "", amountSatoshis: 0 };
}

export const BroadcastAwaitingConfirmation = {
  encode(message: BroadcastAwaitingConfirmation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== undefined) {
      writer.uint32(10).string(message.channelId);
    }
    if (message.latestBroadcastHeight !== 0) {
      writer.uint32(16).uint32(message.latestBroadcastHeight);
    }
    if (message.latestSpendingTxid !== "") {
      writer.uint32(26).string(message.latestSpendingTxid);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(32).uint64(message.amountSatoshis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastAwaitingConfirmation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastAwaitingConfirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.latestBroadcastHeight = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestSpendingTxid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastAwaitingConfirmation {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : undefined,
      latestBroadcastHeight: isSet(object.latestBroadcastHeight) ? globalThis.Number(object.latestBroadcastHeight) : 0,
      latestSpendingTxid: isSet(object.latestSpendingTxid) ? globalThis.String(object.latestSpendingTxid) : "",
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
    };
  },

  toJSON(message: BroadcastAwaitingConfirmation): unknown {
    const obj: any = {};
    if (message.channelId !== undefined) {
      obj.channelId = message.channelId;
    }
    if (message.latestBroadcastHeight !== 0) {
      obj.latestBroadcastHeight = Math.round(message.latestBroadcastHeight);
    }
    if (message.latestSpendingTxid !== "") {
      obj.latestSpendingTxid = message.latestSpendingTxid;
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastAwaitingConfirmation>, I>>(base?: I): BroadcastAwaitingConfirmation {
    return BroadcastAwaitingConfirmation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastAwaitingConfirmation>, I>>(
    object: I,
  ): BroadcastAwaitingConfirmation {
    const message = createBaseBroadcastAwaitingConfirmation();
    message.channelId = object.channelId ?? undefined;
    message.latestBroadcastHeight = object.latestBroadcastHeight ?? 0;
    message.latestSpendingTxid = object.latestSpendingTxid ?? "";
    message.amountSatoshis = object.amountSatoshis ?? 0;
    return message;
  },
};

function createBaseAwaitingThresholdConfirmations(): AwaitingThresholdConfirmations {
  return {
    channelId: undefined,
    latestSpendingTxid: "",
    confirmationHash: "",
    confirmationHeight: 0,
    amountSatoshis: 0,
  };
}

export const AwaitingThresholdConfirmations = {
  encode(message: AwaitingThresholdConfirmations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== undefined) {
      writer.uint32(10).string(message.channelId);
    }
    if (message.latestSpendingTxid !== "") {
      writer.uint32(18).string(message.latestSpendingTxid);
    }
    if (message.confirmationHash !== "") {
      writer.uint32(26).string(message.confirmationHash);
    }
    if (message.confirmationHeight !== 0) {
      writer.uint32(32).uint32(message.confirmationHeight);
    }
    if (message.amountSatoshis !== 0) {
      writer.uint32(40).uint64(message.amountSatoshis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AwaitingThresholdConfirmations {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwaitingThresholdConfirmations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestSpendingTxid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.confirmationHash = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.confirmationHeight = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amountSatoshis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwaitingThresholdConfirmations {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : undefined,
      latestSpendingTxid: isSet(object.latestSpendingTxid) ? globalThis.String(object.latestSpendingTxid) : "",
      confirmationHash: isSet(object.confirmationHash) ? globalThis.String(object.confirmationHash) : "",
      confirmationHeight: isSet(object.confirmationHeight) ? globalThis.Number(object.confirmationHeight) : 0,
      amountSatoshis: isSet(object.amountSatoshis) ? globalThis.Number(object.amountSatoshis) : 0,
    };
  },

  toJSON(message: AwaitingThresholdConfirmations): unknown {
    const obj: any = {};
    if (message.channelId !== undefined) {
      obj.channelId = message.channelId;
    }
    if (message.latestSpendingTxid !== "") {
      obj.latestSpendingTxid = message.latestSpendingTxid;
    }
    if (message.confirmationHash !== "") {
      obj.confirmationHash = message.confirmationHash;
    }
    if (message.confirmationHeight !== 0) {
      obj.confirmationHeight = Math.round(message.confirmationHeight);
    }
    if (message.amountSatoshis !== 0) {
      obj.amountSatoshis = Math.round(message.amountSatoshis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AwaitingThresholdConfirmations>, I>>(base?: I): AwaitingThresholdConfirmations {
    return AwaitingThresholdConfirmations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwaitingThresholdConfirmations>, I>>(
    object: I,
  ): AwaitingThresholdConfirmations {
    const message = createBaseAwaitingThresholdConfirmations();
    message.channelId = object.channelId ?? undefined;
    message.latestSpendingTxid = object.latestSpendingTxid ?? "";
    message.confirmationHash = object.confirmationHash ?? "";
    message.confirmationHeight = object.confirmationHeight ?? 0;
    message.amountSatoshis = object.amountSatoshis ?? 0;
    return message;
  },
};

function createBasePendingSweepBalance(): PendingSweepBalance {
  return {
    pendingBroadcast: undefined,
    broadcastAwaitingConfirmation: undefined,
    awaitingThresholdConfirmations: undefined,
  };
}

export const PendingSweepBalance = {
  encode(message: PendingSweepBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pendingBroadcast !== undefined) {
      PendingBroadcast.encode(message.pendingBroadcast, writer.uint32(10).fork()).ldelim();
    }
    if (message.broadcastAwaitingConfirmation !== undefined) {
      BroadcastAwaitingConfirmation.encode(message.broadcastAwaitingConfirmation, writer.uint32(18).fork()).ldelim();
    }
    if (message.awaitingThresholdConfirmations !== undefined) {
      AwaitingThresholdConfirmations.encode(message.awaitingThresholdConfirmations, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PendingSweepBalance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingSweepBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pendingBroadcast = PendingBroadcast.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.broadcastAwaitingConfirmation = BroadcastAwaitingConfirmation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.awaitingThresholdConfirmations = AwaitingThresholdConfirmations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingSweepBalance {
    return {
      pendingBroadcast: isSet(object.pendingBroadcast) ? PendingBroadcast.fromJSON(object.pendingBroadcast) : undefined,
      broadcastAwaitingConfirmation: isSet(object.broadcastAwaitingConfirmation)
        ? BroadcastAwaitingConfirmation.fromJSON(object.broadcastAwaitingConfirmation)
        : undefined,
      awaitingThresholdConfirmations: isSet(object.awaitingThresholdConfirmations)
        ? AwaitingThresholdConfirmations.fromJSON(object.awaitingThresholdConfirmations)
        : undefined,
    };
  },

  toJSON(message: PendingSweepBalance): unknown {
    const obj: any = {};
    if (message.pendingBroadcast !== undefined) {
      obj.pendingBroadcast = PendingBroadcast.toJSON(message.pendingBroadcast);
    }
    if (message.broadcastAwaitingConfirmation !== undefined) {
      obj.broadcastAwaitingConfirmation = BroadcastAwaitingConfirmation.toJSON(message.broadcastAwaitingConfirmation);
    }
    if (message.awaitingThresholdConfirmations !== undefined) {
      obj.awaitingThresholdConfirmations = AwaitingThresholdConfirmations.toJSON(
        message.awaitingThresholdConfirmations,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingSweepBalance>, I>>(base?: I): PendingSweepBalance {
    return PendingSweepBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingSweepBalance>, I>>(object: I): PendingSweepBalance {
    const message = createBasePendingSweepBalance();
    message.pendingBroadcast = (object.pendingBroadcast !== undefined && object.pendingBroadcast !== null)
      ? PendingBroadcast.fromPartial(object.pendingBroadcast)
      : undefined;
    message.broadcastAwaitingConfirmation =
      (object.broadcastAwaitingConfirmation !== undefined && object.broadcastAwaitingConfirmation !== null)
        ? BroadcastAwaitingConfirmation.fromPartial(object.broadcastAwaitingConfirmation)
        : undefined;
    message.awaitingThresholdConfirmations =
      (object.awaitingThresholdConfirmations !== undefined && object.awaitingThresholdConfirmations !== null)
        ? AwaitingThresholdConfirmations.fromPartial(object.awaitingThresholdConfirmations)
        : undefined;
    return message;
  },
};

function createBaseGetBalancesRequest(): GetBalancesRequest {
  return {};
}

export const GetBalancesRequest = {
  encode(_: GetBalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBalancesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetBalancesRequest {
    return {};
  },

  toJSON(_: GetBalancesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalancesRequest>, I>>(base?: I): GetBalancesRequest {
    return GetBalancesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalancesRequest>, I>>(_: I): GetBalancesRequest {
    const message = createBaseGetBalancesRequest();
    return message;
  },
};

function createBaseGetBalancesResponse(): GetBalancesResponse {
  return {
    totalOnchainBalanceSats: 0,
    spendableOnchainBalanceSats: 0,
    totalAnchorChannelsReserveSats: 0,
    totalLightningBalanceSats: 0,
    lightningBalances: [],
    pendingBalancesFromChannelClosures: [],
  };
}

export const GetBalancesResponse = {
  encode(message: GetBalancesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalOnchainBalanceSats !== 0) {
      writer.uint32(8).uint64(message.totalOnchainBalanceSats);
    }
    if (message.spendableOnchainBalanceSats !== 0) {
      writer.uint32(16).uint64(message.spendableOnchainBalanceSats);
    }
    if (message.totalAnchorChannelsReserveSats !== 0) {
      writer.uint32(24).uint64(message.totalAnchorChannelsReserveSats);
    }
    if (message.totalLightningBalanceSats !== 0) {
      writer.uint32(32).uint64(message.totalLightningBalanceSats);
    }
    for (const v of message.lightningBalances) {
      LightningBalance.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.pendingBalancesFromChannelClosures) {
      PendingSweepBalance.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBalancesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalOnchainBalanceSats = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.spendableOnchainBalanceSats = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalAnchorChannelsReserveSats = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLightningBalanceSats = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lightningBalances.push(LightningBalance.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pendingBalancesFromChannelClosures.push(PendingSweepBalance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalancesResponse {
    return {
      totalOnchainBalanceSats: isSet(object.totalOnchainBalanceSats)
        ? globalThis.Number(object.totalOnchainBalanceSats)
        : 0,
      spendableOnchainBalanceSats: isSet(object.spendableOnchainBalanceSats)
        ? globalThis.Number(object.spendableOnchainBalanceSats)
        : 0,
      totalAnchorChannelsReserveSats: isSet(object.totalAnchorChannelsReserveSats)
        ? globalThis.Number(object.totalAnchorChannelsReserveSats)
        : 0,
      totalLightningBalanceSats: isSet(object.totalLightningBalanceSats)
        ? globalThis.Number(object.totalLightningBalanceSats)
        : 0,
      lightningBalances: globalThis.Array.isArray(object?.lightningBalances)
        ? object.lightningBalances.map((e: any) => LightningBalance.fromJSON(e))
        : [],
      pendingBalancesFromChannelClosures: globalThis.Array.isArray(object?.pendingBalancesFromChannelClosures)
        ? object.pendingBalancesFromChannelClosures.map((e: any) => PendingSweepBalance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBalancesResponse): unknown {
    const obj: any = {};
    if (message.totalOnchainBalanceSats !== 0) {
      obj.totalOnchainBalanceSats = Math.round(message.totalOnchainBalanceSats);
    }
    if (message.spendableOnchainBalanceSats !== 0) {
      obj.spendableOnchainBalanceSats = Math.round(message.spendableOnchainBalanceSats);
    }
    if (message.totalAnchorChannelsReserveSats !== 0) {
      obj.totalAnchorChannelsReserveSats = Math.round(message.totalAnchorChannelsReserveSats);
    }
    if (message.totalLightningBalanceSats !== 0) {
      obj.totalLightningBalanceSats = Math.round(message.totalLightningBalanceSats);
    }
    if (message.lightningBalances?.length) {
      obj.lightningBalances = message.lightningBalances.map((e) => LightningBalance.toJSON(e));
    }
    if (message.pendingBalancesFromChannelClosures?.length) {
      obj.pendingBalancesFromChannelClosures = message.pendingBalancesFromChannelClosures.map((e) =>
        PendingSweepBalance.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalancesResponse>, I>>(base?: I): GetBalancesResponse {
    return GetBalancesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalancesResponse>, I>>(object: I): GetBalancesResponse {
    const message = createBaseGetBalancesResponse();
    message.totalOnchainBalanceSats = object.totalOnchainBalanceSats ?? 0;
    message.spendableOnchainBalanceSats = object.spendableOnchainBalanceSats ?? 0;
    message.totalAnchorChannelsReserveSats = object.totalAnchorChannelsReserveSats ?? 0;
    message.totalLightningBalanceSats = object.totalLightningBalanceSats ?? 0;
    message.lightningBalances = object.lightningBalances?.map((e) => LightningBalance.fromPartial(e)) || [];
    message.pendingBalancesFromChannelClosures =
      object.pendingBalancesFromChannelClosures?.map((e) => PendingSweepBalance.fromPartial(e)) || [];
    return message;
  },
};

function createBasePaymentDetails(): PaymentDetails {
  return { id: undefined, kind: undefined, amountMsat: undefined, direction: 0, status: 0, latestUpdateTimestamp: 0 };
}

export const PaymentDetails = {
  encode(message: PaymentDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      PaymentId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.kind !== undefined) {
      PaymentKind.encode(message.kind, writer.uint32(18).fork()).ldelim();
    }
    if (message.amountMsat !== undefined) {
      writer.uint32(24).uint64(message.amountMsat);
    }
    if (message.direction !== 0) {
      writer.uint32(32).int32(message.direction);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.latestUpdateTimestamp !== 0) {
      writer.uint32(48).uint64(message.latestUpdateTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = PaymentId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = PaymentKind.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amountMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.latestUpdateTimestamp = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentDetails {
    return {
      id: isSet(object.id) ? PaymentId.fromJSON(object.id) : undefined,
      kind: isSet(object.kind) ? PaymentKind.fromJSON(object.kind) : undefined,
      amountMsat: isSet(object.amountMsat) ? globalThis.Number(object.amountMsat) : undefined,
      direction: isSet(object.direction) ? paymentDirectionFromJSON(object.direction) : 0,
      status: isSet(object.status) ? paymentStatusFromJSON(object.status) : 0,
      latestUpdateTimestamp: isSet(object.latestUpdateTimestamp) ? globalThis.Number(object.latestUpdateTimestamp) : 0,
    };
  },

  toJSON(message: PaymentDetails): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = PaymentId.toJSON(message.id);
    }
    if (message.kind !== undefined) {
      obj.kind = PaymentKind.toJSON(message.kind);
    }
    if (message.amountMsat !== undefined) {
      obj.amountMsat = Math.round(message.amountMsat);
    }
    if (message.direction !== 0) {
      obj.direction = paymentDirectionToJSON(message.direction);
    }
    if (message.status !== 0) {
      obj.status = paymentStatusToJSON(message.status);
    }
    if (message.latestUpdateTimestamp !== 0) {
      obj.latestUpdateTimestamp = Math.round(message.latestUpdateTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentDetails>, I>>(base?: I): PaymentDetails {
    return PaymentDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentDetails>, I>>(object: I): PaymentDetails {
    const message = createBasePaymentDetails();
    message.id = (object.id !== undefined && object.id !== null) ? PaymentId.fromPartial(object.id) : undefined;
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? PaymentKind.fromPartial(object.kind)
      : undefined;
    message.amountMsat = object.amountMsat ?? undefined;
    message.direction = object.direction ?? 0;
    message.status = object.status ?? 0;
    message.latestUpdateTimestamp = object.latestUpdateTimestamp ?? 0;
    return message;
  },
};

function createBasePaymentKind(): PaymentKind {
  return {
    onchain: undefined,
    bolt11: undefined,
    bolt11Jit: undefined,
    bolt12offer: undefined,
    bolt12refund: undefined,
    spontaneous: undefined,
  };
}

export const PaymentKind = {
  encode(message: PaymentKind, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.onchain !== undefined) {
      Onchain.encode(message.onchain, writer.uint32(10).fork()).ldelim();
    }
    if (message.bolt11 !== undefined) {
      Bolt11.encode(message.bolt11, writer.uint32(18).fork()).ldelim();
    }
    if (message.bolt11Jit !== undefined) {
      Bolt11Jit.encode(message.bolt11Jit, writer.uint32(26).fork()).ldelim();
    }
    if (message.bolt12offer !== undefined) {
      Bolt12Offer.encode(message.bolt12offer, writer.uint32(34).fork()).ldelim();
    }
    if (message.bolt12refund !== undefined) {
      Bolt12Refund.encode(message.bolt12refund, writer.uint32(42).fork()).ldelim();
    }
    if (message.spontaneous !== undefined) {
      Spontaneous.encode(message.spontaneous, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentKind {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentKind();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.onchain = Onchain.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bolt11 = Bolt11.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bolt11Jit = Bolt11Jit.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bolt12offer = Bolt12Offer.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bolt12refund = Bolt12Refund.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.spontaneous = Spontaneous.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentKind {
    return {
      onchain: isSet(object.onchain) ? Onchain.fromJSON(object.onchain) : undefined,
      bolt11: isSet(object.bolt11) ? Bolt11.fromJSON(object.bolt11) : undefined,
      bolt11Jit: isSet(object.bolt11Jit) ? Bolt11Jit.fromJSON(object.bolt11Jit) : undefined,
      bolt12offer: isSet(object.bolt12offer) ? Bolt12Offer.fromJSON(object.bolt12offer) : undefined,
      bolt12refund: isSet(object.bolt12refund) ? Bolt12Refund.fromJSON(object.bolt12refund) : undefined,
      spontaneous: isSet(object.spontaneous) ? Spontaneous.fromJSON(object.spontaneous) : undefined,
    };
  },

  toJSON(message: PaymentKind): unknown {
    const obj: any = {};
    if (message.onchain !== undefined) {
      obj.onchain = Onchain.toJSON(message.onchain);
    }
    if (message.bolt11 !== undefined) {
      obj.bolt11 = Bolt11.toJSON(message.bolt11);
    }
    if (message.bolt11Jit !== undefined) {
      obj.bolt11Jit = Bolt11Jit.toJSON(message.bolt11Jit);
    }
    if (message.bolt12offer !== undefined) {
      obj.bolt12offer = Bolt12Offer.toJSON(message.bolt12offer);
    }
    if (message.bolt12refund !== undefined) {
      obj.bolt12refund = Bolt12Refund.toJSON(message.bolt12refund);
    }
    if (message.spontaneous !== undefined) {
      obj.spontaneous = Spontaneous.toJSON(message.spontaneous);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentKind>, I>>(base?: I): PaymentKind {
    return PaymentKind.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentKind>, I>>(object: I): PaymentKind {
    const message = createBasePaymentKind();
    message.onchain = (object.onchain !== undefined && object.onchain !== null)
      ? Onchain.fromPartial(object.onchain)
      : undefined;
    message.bolt11 = (object.bolt11 !== undefined && object.bolt11 !== null)
      ? Bolt11.fromPartial(object.bolt11)
      : undefined;
    message.bolt11Jit = (object.bolt11Jit !== undefined && object.bolt11Jit !== null)
      ? Bolt11Jit.fromPartial(object.bolt11Jit)
      : undefined;
    message.bolt12offer = (object.bolt12offer !== undefined && object.bolt12offer !== null)
      ? Bolt12Offer.fromPartial(object.bolt12offer)
      : undefined;
    message.bolt12refund = (object.bolt12refund !== undefined && object.bolt12refund !== null)
      ? Bolt12Refund.fromPartial(object.bolt12refund)
      : undefined;
    message.spontaneous = (object.spontaneous !== undefined && object.spontaneous !== null)
      ? Spontaneous.fromPartial(object.spontaneous)
      : undefined;
    return message;
  },
};

function createBaseOnchain(): Onchain {
  return {};
}

export const Onchain = {
  encode(_: Onchain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Onchain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Onchain {
    return {};
  },

  toJSON(_: Onchain): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Onchain>, I>>(base?: I): Onchain {
    return Onchain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Onchain>, I>>(_: I): Onchain {
    const message = createBaseOnchain();
    return message;
  },
};

function createBaseBolt11(): Bolt11 {
  return { hash: "", preimage: undefined, secret: undefined };
}

export const Bolt11 = {
  encode(message: Bolt11, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(18).string(message.preimage);
    }
    if (message.secret !== undefined) {
      writer.uint32(26).bytes(message.secret);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secret = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11 {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : undefined,
    };
  },

  toJSON(message: Bolt11): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    if (message.secret !== undefined) {
      obj.secret = base64FromBytes(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11>, I>>(base?: I): Bolt11 {
    return Bolt11.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11>, I>>(object: I): Bolt11 {
    const message = createBaseBolt11();
    message.hash = object.hash ?? "";
    message.preimage = object.preimage ?? undefined;
    message.secret = object.secret ?? undefined;
    return message;
  },
};

function createBaseBolt11Jit(): Bolt11Jit {
  return { hash: "", preimage: undefined, secret: undefined, lspFeeLimits: undefined };
}

export const Bolt11Jit = {
  encode(message: Bolt11Jit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(18).string(message.preimage);
    }
    if (message.secret !== undefined) {
      writer.uint32(26).bytes(message.secret);
    }
    if (message.lspFeeLimits !== undefined) {
      LSPFeeLimits.encode(message.lspFeeLimits, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt11Jit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt11Jit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secret = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lspFeeLimits = LSPFeeLimits.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt11Jit {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : undefined,
      lspFeeLimits: isSet(object.lspFeeLimits) ? LSPFeeLimits.fromJSON(object.lspFeeLimits) : undefined,
    };
  },

  toJSON(message: Bolt11Jit): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    if (message.secret !== undefined) {
      obj.secret = base64FromBytes(message.secret);
    }
    if (message.lspFeeLimits !== undefined) {
      obj.lspFeeLimits = LSPFeeLimits.toJSON(message.lspFeeLimits);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt11Jit>, I>>(base?: I): Bolt11Jit {
    return Bolt11Jit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt11Jit>, I>>(object: I): Bolt11Jit {
    const message = createBaseBolt11Jit();
    message.hash = object.hash ?? "";
    message.preimage = object.preimage ?? undefined;
    message.secret = object.secret ?? undefined;
    message.lspFeeLimits = (object.lspFeeLimits !== undefined && object.lspFeeLimits !== null)
      ? LSPFeeLimits.fromPartial(object.lspFeeLimits)
      : undefined;
    return message;
  },
};

function createBaseBolt12Offer(): Bolt12Offer {
  return { hash: undefined, preimage: undefined, secret: undefined, offerId: new Uint8Array(0) };
}

export const Bolt12Offer = {
  encode(message: Bolt12Offer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined) {
      writer.uint32(10).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(18).string(message.preimage);
    }
    if (message.secret !== undefined) {
      writer.uint32(26).bytes(message.secret);
    }
    if (message.offerId.length !== 0) {
      writer.uint32(34).bytes(message.offerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12Offer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12Offer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secret = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.offerId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12Offer {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : undefined,
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : undefined,
      offerId: isSet(object.offerId) ? bytesFromBase64(object.offerId) : new Uint8Array(0),
    };
  },

  toJSON(message: Bolt12Offer): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    if (message.secret !== undefined) {
      obj.secret = base64FromBytes(message.secret);
    }
    if (message.offerId.length !== 0) {
      obj.offerId = base64FromBytes(message.offerId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12Offer>, I>>(base?: I): Bolt12Offer {
    return Bolt12Offer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12Offer>, I>>(object: I): Bolt12Offer {
    const message = createBaseBolt12Offer();
    message.hash = object.hash ?? undefined;
    message.preimage = object.preimage ?? undefined;
    message.secret = object.secret ?? undefined;
    message.offerId = object.offerId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBolt12Refund(): Bolt12Refund {
  return { hash: undefined, preimage: undefined, secret: undefined };
}

export const Bolt12Refund = {
  encode(message: Bolt12Refund, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined) {
      writer.uint32(10).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(18).string(message.preimage);
    }
    if (message.secret !== undefined) {
      writer.uint32(26).bytes(message.secret);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bolt12Refund {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBolt12Refund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secret = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bolt12Refund {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : undefined,
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : undefined,
    };
  },

  toJSON(message: Bolt12Refund): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    if (message.secret !== undefined) {
      obj.secret = base64FromBytes(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bolt12Refund>, I>>(base?: I): Bolt12Refund {
    return Bolt12Refund.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bolt12Refund>, I>>(object: I): Bolt12Refund {
    const message = createBaseBolt12Refund();
    message.hash = object.hash ?? undefined;
    message.preimage = object.preimage ?? undefined;
    message.secret = object.secret ?? undefined;
    return message;
  },
};

function createBaseSpontaneous(): Spontaneous {
  return { hash: "", preimage: undefined };
}

export const Spontaneous = {
  encode(message: Spontaneous, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(18).string(message.preimage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Spontaneous {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpontaneous();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spontaneous {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
    };
  },

  toJSON(message: Spontaneous): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spontaneous>, I>>(base?: I): Spontaneous {
    return Spontaneous.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spontaneous>, I>>(object: I): Spontaneous {
    const message = createBaseSpontaneous();
    message.hash = object.hash ?? "";
    message.preimage = object.preimage ?? undefined;
    return message;
  },
};

function createBaseLSPFeeLimits(): LSPFeeLimits {
  return { maxTotalOpeningFeeMsat: undefined, maxProportionalOpeningFeePpmMsat: undefined };
}

export const LSPFeeLimits = {
  encode(message: LSPFeeLimits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxTotalOpeningFeeMsat !== undefined) {
      writer.uint32(8).uint64(message.maxTotalOpeningFeeMsat);
    }
    if (message.maxProportionalOpeningFeePpmMsat !== undefined) {
      writer.uint32(16).uint64(message.maxProportionalOpeningFeePpmMsat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LSPFeeLimits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLSPFeeLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxTotalOpeningFeeMsat = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxProportionalOpeningFeePpmMsat = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LSPFeeLimits {
    return {
      maxTotalOpeningFeeMsat: isSet(object.maxTotalOpeningFeeMsat)
        ? globalThis.Number(object.maxTotalOpeningFeeMsat)
        : undefined,
      maxProportionalOpeningFeePpmMsat: isSet(object.maxProportionalOpeningFeePpmMsat)
        ? globalThis.Number(object.maxProportionalOpeningFeePpmMsat)
        : undefined,
    };
  },

  toJSON(message: LSPFeeLimits): unknown {
    const obj: any = {};
    if (message.maxTotalOpeningFeeMsat !== undefined) {
      obj.maxTotalOpeningFeeMsat = Math.round(message.maxTotalOpeningFeeMsat);
    }
    if (message.maxProportionalOpeningFeePpmMsat !== undefined) {
      obj.maxProportionalOpeningFeePpmMsat = Math.round(message.maxProportionalOpeningFeePpmMsat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LSPFeeLimits>, I>>(base?: I): LSPFeeLimits {
    return LSPFeeLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LSPFeeLimits>, I>>(object: I): LSPFeeLimits {
    const message = createBaseLSPFeeLimits();
    message.maxTotalOpeningFeeMsat = object.maxTotalOpeningFeeMsat ?? undefined;
    message.maxProportionalOpeningFeePpmMsat = object.maxProportionalOpeningFeePpmMsat ?? undefined;
    return message;
  },
};

function createBasePaymentsHistoryRequest(): PaymentsHistoryRequest {
  return {};
}

export const PaymentsHistoryRequest = {
  encode(_: PaymentsHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentsHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentsHistoryRequest {
    return {};
  },

  toJSON(_: PaymentsHistoryRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsHistoryRequest>, I>>(base?: I): PaymentsHistoryRequest {
    return PaymentsHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsHistoryRequest>, I>>(_: I): PaymentsHistoryRequest {
    const message = createBasePaymentsHistoryRequest();
    return message;
  },
};

function createBasePaymentsHistoryResponse(): PaymentsHistoryResponse {
  return { payments: [] };
}

export const PaymentsHistoryResponse = {
  encode(message: PaymentsHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payments) {
      PaymentDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentsHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payments.push(PaymentDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsHistoryResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => PaymentDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PaymentsHistoryResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => PaymentDetails.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsHistoryResponse>, I>>(base?: I): PaymentsHistoryResponse {
    return PaymentsHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsHistoryResponse>, I>>(object: I): PaymentsHistoryResponse {
    const message = createBasePaymentsHistoryResponse();
    message.payments = object.payments?.map((e) => PaymentDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPaymentDetailsRequest(): GetPaymentDetailsRequest {
  return { paymentId: "" };
}

export const GetPaymentDetailsRequest = {
  encode(message: GetPaymentDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPaymentDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentDetailsRequest {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: GetPaymentDetailsRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentDetailsRequest>, I>>(base?: I): GetPaymentDetailsRequest {
    return GetPaymentDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentDetailsRequest>, I>>(object: I): GetPaymentDetailsRequest {
    const message = createBaseGetPaymentDetailsRequest();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseGetPaymentDetailsResponse(): GetPaymentDetailsResponse {
  return { payment: undefined };
}

export const GetPaymentDetailsResponse = {
  encode(message: GetPaymentDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payment !== undefined) {
      PaymentDetails.encode(message.payment, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPaymentDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payment = PaymentDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentDetailsResponse {
    return { payment: isSet(object.payment) ? PaymentDetails.fromJSON(object.payment) : undefined };
  },

  toJSON(message: GetPaymentDetailsResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = PaymentDetails.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentDetailsResponse>, I>>(base?: I): GetPaymentDetailsResponse {
    return GetPaymentDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentDetailsResponse>, I>>(object: I): GetPaymentDetailsResponse {
    const message = createBaseGetPaymentDetailsResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? PaymentDetails.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
